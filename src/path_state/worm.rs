use super::sector::Sector;
use super::traits::WorldLineDimensions;
use super::traits::WorldLinePermutationAccess;
use super::traits::WorldLinePositionAccess;
use super::traits::WorldLineWormAccess;
use ndarray::{arr1, s, Array, Array1, Array2, Array3, ArrayView1, ArrayView2, ArrayViewMut1};
use serde::{Deserialize, Serialize};
use serde_json;
use std::fs::File;
use std::io::{self, BufReader, BufWriter};

/// Worm struct to store particle positions using ndarray.
///
/// # Example
/// ```
/// use pimc_rs::path_state::worm::Worm;
/// use crate::pimc_rs::path_state::traits::WorldLinePositionAccess;
///
/// // Create a new Worm instance
/// let mut world = Worm::<2,3,3>::new(); // 2 particles, 3 time slices, 3D space
///
/// // Set the position of the first particle at the first time slice
/// world.set_position(0, 0, &[1.0, 2.0, 3.0]);
///
/// // Retrieve the position
/// let position = world.position(0, 0);
/// assert_eq!(position.to_vec(), vec![1.0, 2.0, 3.0]);
/// ```
///
#[derive(Clone, Serialize, Deserialize)]
pub struct Worm<const N: usize, const M: usize, const D: usize> {
    /// Multidimensional array with const generics dimensions
    /// (N particles, M time slices, D spatial dimensions).
    positions: Array3<f64>,
    prev_permutation: Array1<i32>, // -1 for open worldlines
    next_permutation: Array1<i32>, // -1 for open worldlines
    worm_head: Option<usize>,
    worm_tail: Option<usize>,
    sector: Sector,
}

#[allow(clippy::new_without_default)]
impl<const N: usize, const M: usize, const D: usize> Worm<N, M, D> {
    /// Creates a new `Worm` instance with all positions initialized to zero.
    pub fn new() -> Self {
        Self {
            positions: Array::zeros((N, M, D)),
            prev_permutation: Array1::from_iter((0..N).map(|i| i as i32)),
            next_permutation: Array1::from_iter((0..N).map(|i| i as i32)),
            worm_head: None,
            worm_tail: None,
            sector: Sector::Z,
        }
    }

    /// Initializes all slices of each particle a position vector generated by the input function.
    ///
    /// # Arguments
    /// * `position_generator` - A function or closure that takes a particle index
    ///   and returns a position vector of length `D`.
    ///
    /// # Panics
    /// Panics if the generated position vector does not match the spatial dimension `D`.
    ///
    /// # Example
    /// ```
    /// use pimc_rs::path_state::worm::Worm;
    /// use ndarray::array;
    /// use crate::pimc_rs::path_state::traits::WorldLinePositionAccess;
    ///
    /// let mut world = Worm::<2, 3, 3>::new();
    ///
    /// // Initialize positions with a simple function
    /// world.initialize_positions(|particle| vec![particle as f64; 3]);
    ///
    /// // Verify initialization
    /// assert_eq!(world.position(0, 0), array![0.0, 0.0, 0.0]);
    /// assert_eq!(world.position(1, 1), array![1.0, 1.0, 1.0]);
    /// ```
    pub fn initialize_positions<F>(&mut self, position_generator: F)
    where
        F: Fn(usize) -> Vec<f64>,
    {
        for particle in 0..N {
            // Generate the position vector for the current particle
            let position = position_generator(particle);
            assert_eq!(
                position.len(),
                D,
                "Generated position length mismatch: expected={}, got={}",
                D,
                position.len()
            );

            // Set all slices for the current particle to the same position vector
            for time_slice in 0..M {
                self.set_position(particle, time_slice, &position);
            }
        }
    }

    /// Saves the `Worm` instance to a file in JSON format.
    ///
    /// # Arguments
    /// * `filename` - Path to the output JSON file.
    ///
    /// # Errors
    /// Returns an error if the file cannot be created or written to.
    ///
    pub fn save_to_file(&self, filename: &str) -> io::Result<()> {
        let file = File::create(filename)?;
        let writer = BufWriter::new(file);
        serde_json::to_writer(writer, &self)?;
        Ok(())
    }

    /// Loads a `Worm` instance from a JSON file.
    ///
    /// # Arguments
    /// * `filename` - Path to the input JSON file.
    ///
    /// # Errors
    /// Returns an error if the file cannot be read or is invalid.
    ///
    pub fn load_from_file(filename: &str) -> io::Result<Self> {
        let file = File::open(filename)?;
        let reader = BufReader::new(file);
        let world_lines = serde_json::from_reader(reader)?;
        Ok(world_lines)
    }
}

impl<const N: usize, const M: usize, const D: usize> WorldLineDimensions for Worm<N, M, D> {
    /// Returns the number of particles in the system.
    fn particles(&self) -> usize {
        N
    }

    /// Returns the number of time slices in the system.
    fn time_slices(&self) -> usize {
        M
    }

    /// Returns the number of spatial dimensions.
    fn spatial_dimensions(&self) -> usize {
        D
    }
}

impl<const N: usize, const M: usize, const D: usize> WorldLinePositionAccess for Worm<N, M, D> {
    /// Gets a view of the position of a specific particle at a specific time slice.
    ///
    /// # Arguments
    /// * `particle` - Index of the particle.
    /// * `time_slice` - Index of the time slice.
    ///
    /// # Returns
    /// An array view of the positions.
    ///
    /// # Panics
    /// Panics if the particle or time_slice indices are out of bounds.
    fn position(&self, particle: usize, time_slice: usize) -> ArrayView1<f64> {
        // Ensure indices are within bounds
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );
        debug_assert!(
            time_slice < M,
            "Time slice index out of bounds: time_slice={}, max allowed={}",
            time_slice,
            M - 1
        );

        self.positions.slice(s![particle, time_slice, ..])
    }

    /// Gets a mutable view of the position of a specific particle at a specific time slice.
    ///
    /// # Arguments
    /// * `particle` - Index of the particle.
    /// * `time_slice` - Index of the time slice.
    ///
    /// # Returns
    /// A mutable array view of the positions.
    ///
    /// # Panics
    /// Panics if the particle or time_slice indices are out of bounds.
    fn position_mut(&mut self, particle: usize, time_slice: usize) -> ArrayViewMut1<f64> {
        // Ensure indices are within bounds
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );
        debug_assert!(
            time_slice < M,
            "Time slice index out of bounds: time_slice={}, max allowed={}",
            time_slice,
            M - 1
        );

        self.positions.slice_mut(s![particle, time_slice, ..])
    }

    /// Sets the position of a specific particle at a specific time slice.
    ///
    /// # Arguments
    /// * `particle` - Index of the particle.
    /// * `time_slice` - Index of the time slice.
    /// * `bead_position` - Vector of positions to set.
    ///
    /// # Panics
    /// Panics if the particle or time_slice indices are out of bounds, or if the length of `bead_position`
    /// does not match the spatial dimension `d`.
    fn set_position(&mut self, particle: usize, time_slice: usize, bead_position: &[f64]) {
        // Ensure indices are within bounds
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );
        debug_assert!(
            time_slice < M,
            "Time slice index out of bounds: time_slice={}, max allowed={}",
            time_slice,
            M - 1
        );

        // Ensure the position vector matches the expected spatial dimension
        debug_assert_eq!(
            bead_position.len(),
            D,
            "Position length mismatch: expected={}, got={}",
            D,
            bead_position.len()
        );

        // Efficiently set the position using the higher order `assign` function
        self.positions
            .slice_mut(s![particle, time_slice, ..])
            .assign(&arr1(bead_position));
    }

    /// Gets a 2D view of the positions for a specific particle across a range of time slices.
    ///
    /// # Arguments
    /// * `particle` - Index of the particle.
    /// * `start_slice` - Starting index of the time slice (inclusive).
    /// * `end_slice` - Ending index of the time slice (exclusive).
    ///
    /// # Returns
    /// A 2D array view of the positions for the specified particle and time slice range.
    ///
    /// # Panics
    /// Panics if:
    /// - The `particle` index is out of bounds.
    /// - The `start_slice` or `end_slice` indices are out of bounds.
    /// - `start_slice >= end_slice`.
    ///
    /// # Example
    /// ```
    /// use pimc_rs::path_state::worm::Worm;
    /// use ndarray::array;
    /// use crate::pimc_rs::path_state::traits::WorldLinePositionAccess;
    ///
    /// let mut world = Worm::<2,5,3>::new(); // 2 particles, 5 time slices, 3D space
    /// world.set_position(0, 0, &[1.0, 2.0, 3.0]);
    /// world.set_position(0, 1, &[4.0, 5.0, 6.0]);
    ///
    /// // Retrieve positions from slice 0 to 2 (exclusive)
    /// let positions = world.positions(0, 0, 2);
    /// assert_eq!(positions, array![[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]);
    /// ```
    fn positions(&self, particle: usize, start_slice: usize, end_slice: usize) -> ArrayView2<f64> {
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );
        debug_assert!(
            start_slice < end_slice,
            "Invalid slice range: start_slice ({}) must be less than end_slice ({})",
            start_slice,
            end_slice
        );
        debug_assert!(
            end_slice <= M,
            "Time slice range out of bounds: end_slice={}, max allowed={}",
            end_slice,
            M
        );

        // Extract and return a 2D view using slicing
        self.positions
            .slice(s![particle, start_slice..end_slice, ..])
    }

    /// Sets the positions for a specific particle across a range of time slices.
    ///
    /// # Arguments
    /// * `particle` - Index of the particle.
    /// * `start_slice` - Starting index of the time slice (inclusive).
    /// * `end_slice` - Ending index of the time slice (exclusive).
    /// * `positions` - A 2D array with shape `(end_slice - start_slice, spatial_dim)` containing the new positions.
    ///
    /// # Panics
    /// Panics if:
    /// - The `particle` index is out of bounds.
    /// - The `start_slice` or `end_slice` indices are out of bounds.
    /// - The `positions` array shape does not match `(end_slice - start_slice, spatial_dim)`.
    ///
    /// # Example
    /// ```
    /// use pimc_rs::path_state::worm::Worm;
    /// use ndarray::array;
    /// use crate::pimc_rs::path_state::traits::WorldLinePositionAccess;
    ///
    /// let mut world = Worm::<2,5,3>::new(); // 2 particles, 5 time slices, 3D space
    ///
    /// // Set positions for slices 0 to 2 (exclusive) for particle 0
    /// let new_positions = array![[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]];
    /// world.set_positions(0, 0, 2, &new_positions);
    ///
    /// // Verify the changes
    /// let positions = world.positions(0, 0, 2);
    /// assert_eq!(positions, new_positions);
    /// ```
    fn set_positions(
        &mut self,
        particle: usize,
        start_slice: usize,
        end_slice: usize,
        positions: &Array2<f64>,
    ) {
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );
        debug_assert!(
            start_slice < end_slice,
            "Invalid slice range: start_slice ({}) must be less than end_slice ({})",
            start_slice,
            end_slice
        );
        debug_assert!(
            end_slice <= M,
            "Time slice range out of bounds: end_slice={}, max allowed={}",
            end_slice,
            M
        );
        debug_assert_eq!(
            positions.shape(),
            &[end_slice - start_slice, D],
            "Input positions shape mismatch: expected ({}, {}), got {:?}",
            end_slice - start_slice,
            D,
            positions.shape()
        );

        // Perform bulk assignment using slice and `assign`
        self.positions
            .slice_mut(s![particle, start_slice..end_slice, ..])
            .assign(positions);
    }
}

impl<const N: usize, const M: usize, const D: usize> WorldLinePermutationAccess for Worm<N, M, D> {
    /// Gets the previous particle for a given particle.
    ///
    /// # Returns
    /// An `Option<usize>` where:
    /// * `Some(value)` indicates the preceding particle index.
    /// * `None` indicates an open worldline (-1).
    fn preceding(&self, particle: usize) -> Option<usize> {
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );
        match self.prev_permutation[particle] {
            -1 => None,
            index => Some(index as usize),
        }
    }

    /// Sets the previous particle permutation for a given particle.
    ///
    /// # Arguments
    /// * `particle` - The particle index to set.
    /// * `prev_particle` - `Some(index)` for a valid preceding particle or `None` for an open worldline.
    ///
    /// # Panics
    /// Panics if `particle` is out of bounds or if `prev_particle` is `Some(value)` and `value` is not in the valid range `0..N`.
    fn set_preceding(&mut self, particle: usize, prev_particle: Option<usize>) {
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );

        match prev_particle {
            Some(index) => {
                debug_assert!(
                    index < N,
                    "Invalid prev_particle value: must be between 0 and N-1, got {}",
                    index
                );
                // Update the permutation
                self.prev_permutation[particle] = index as i32;
                // Update worm_tail as neccessary
                match self.worm_tail {
                    Some(tail) if tail == particle => self.worm_tail = None,
                    _ => (),
                }
            }
            None => {
                // Set tail
                self.prev_permutation[particle] = -1; // Open worldline
                self.worm_tail = Some(particle);
            }
        }
    }

    /// Gets the next particle for a given particle.
    ///
    /// # Returns
    /// An `Option<usize>` where:
    /// * `Some(value)` indicates the following particle index.
    /// * `None` indicates an open worldline (-1).
    fn following(&self, particle: usize) -> Option<usize> {
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );
        match self.next_permutation[particle] {
            -1 => None,
            index => Some(index as usize),
        }
    }

    /// Sets the next particle permutation for a given particle.
    ///
    /// # Arguments
    /// * `particle` - The particle index to set.
    /// * `next_particle` - `Some(index)` for a valid preceding particle or `None` for an open worldline.
    ///
    /// # Panics
    /// Panics if `particle` is out of bounds or if `next_particle` is `Some(value)` and `value` is not in the valid range `0..N`.
    fn set_following(&mut self, particle: usize, next_particle: Option<usize>) {
        debug_assert!(
            particle < N,
            "Particle index out of bounds: particle={}, max allowed={}",
            particle,
            N - 1
        );

        match next_particle {
            Some(index) => {
                debug_assert!(
                    index < N,
                    "Invalid prev_particle value: must be between 0 and N-1, got {}",
                    index
                );
                // Update the permutation
                self.next_permutation[particle] = index as i32;
                // Update worm_head as neccessary
                match self.worm_head {
                    Some(head) if head == particle => self.worm_head = None,
                    _ => (),
                }
            }
            None => {
                // Set head
                self.next_permutation[particle] = -1; // Open worldline
                self.worm_head = Some(particle);
            }
        }
    }
}

impl<const N: usize, const M: usize, const D: usize> WorldLineWormAccess for Worm<N, M, D> {
    /// Gets the sector for a given particle.
    ///
    /// # Returns
    /// A reference to the `Sector` of the worldline.
    fn sector(&self) -> &Sector {
        &self.sector
    }

    /// Gets the worm head particle index, if it exists.
    ///
    /// # Returns
    /// An `Option<usize>`:
    /// * `Some(index)` - The index of the particle acting as the worm head.
    /// * `None` - If there is no worm head in the current configuration.
    fn worm_head(&self) -> Option<usize> {
        self.worm_head
    }

    /// Gets the worm tail particle index, if it exists.
    ///
    /// # Returns
    /// An `Option<usize>`:
    /// * `Some(index)` - The index of the particle acting as the worm head.
    /// * `None` - If there is no worm head in the current configuration.
    fn worm_tail(&self) -> Option<usize> {
        self.worm_tail
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ndarray::array;

    #[test]
    fn test_new_worm() {
        // Test valid initialization
        let world = Worm::<2, 3, 3>::new(); // 2 particles, 3 time slices, 3D
        assert_eq!(world.positions.shape(), &[2, 3, 3]);
    }

    #[test]
    fn test_position() {
        let mut world = Worm::<2, 3, 3>::new();
        world.set_position(0, 0, &[1.0, 2.0, 3.0]);

        // Retrieve position
        let position = world.position(0, 0);
        assert_eq!(position, array![1.0, 2.0, 3.0]);

        // Test out-of-bounds access (should panic)
        let result = std::panic::catch_unwind(|| world.position(2, 0));
        assert!(result.is_err());
    }

    #[test]
    fn test_position_mut() {
        let mut world = Worm::<2, 3, 3>::new();
        {
            // Modify position using mutable reference
            let mut position = world.position_mut(0, 0);
            position.assign(&array![4.0, 5.0, 6.0]);
        }

        // Verify the change
        let position = world.position(0, 0);
        assert_eq!(position, array![4.0, 5.0, 6.0]);
    }

    #[test]
    #[should_panic]
    fn test_invalid_arguments_position_mut() {
        let mut world = Worm::<2, 3, 2>::new();
        world.position_mut(1, 3);
    }

    #[test]
    fn test_positions() {
        let mut world = Worm::<2, 5, 3>::new(); // 2 particles, 5 time slices, 3D space

        // Set positions for particle 0, slices 0 to 2
        world.set_position(0, 0, &[1.0, 2.0, 3.0]);
        world.set_position(0, 1, &[4.0, 5.0, 6.0]);

        // Get positions for slices 0 to 2 (exclusive) for particle 0
        let positions = world.positions(0, 0, 2);
        assert_eq!(positions, array![[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]);
    }

    #[test]
    fn test_set_positions() {
        let mut world = Worm::<2, 5, 3>::new(); // 2 particles, 5 time slices, 3D space

        // Create a 2D array with new positions for slices 0 to 2
        let new_positions = array![
            [1.0, 2.0, 3.0], // Slice 0
            [4.0, 5.0, 6.0], // Slice 1
        ];

        // Set positions for particle 0, slices 0 to 2
        world.set_positions(0, 0, 2, &new_positions);

        // Verify the changes using positions
        let positions = world.positions(0, 0, 2);
        assert_eq!(positions, new_positions);
    }

    #[test]
    fn test_set_permutations() {
        const NP: usize = 4;
        const NS: usize = 16;
        const ND: usize = 3;
        let mut world = Worm::<NP, NS, ND>::new();

        // Worldlines are initialized in the Z sector with all 1-cycle permutations
        for i in 0..NP {
            assert_eq!(world.preceding(i), Some(i));
            assert_eq!(world.following(i), Some(i));
        }

        // Create a 2-cycle
        world.set_preceding(0, Some(NP - 1));
        world.set_following(0, Some(NP - 1));
        world.set_preceding(NP - 1, Some(0));
        world.set_following(NP - 1, Some(0));
        assert_eq!(world.preceding(0), Some(NP - 1));
        assert_eq!(world.worm_tail(), None);
        assert_eq!(world.worm_head(), None);

        // Break the cycle
        world.set_preceding(0, None);
        world.set_following(NP - 1, None);
        assert_eq!(world.worm_tail(), Some(0));
        assert_eq!(world.worm_head(), Some(NP - 1));
    }

    #[test]
    fn test_save_and_load_json_temp() -> io::Result<()> {
        let mut world = Worm::<2, 3, 3>::new();
        world.set_position(0, 0, &[1.0, 2.0, 3.0]);

        // Use a temporary file for saving
        use tempfile::NamedTempFile;
        let temp_file = NamedTempFile::new()?;
        world.save_to_file(temp_file.path().to_str().unwrap())?;

        // Load from the temporary file
        let loaded_world = Worm::<2, 3, 3>::load_from_file(temp_file.path().to_str().unwrap())?;

        // Verify the data
        assert_eq!(loaded_world.position(0, 0), array![1.0, 2.0, 3.0]);

        Ok(())
    }
}
